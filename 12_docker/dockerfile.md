# Dockerfile

В этом руководстве мы посмотрим, как упаковать сервис [из предыдущего ДЗ](https://github.com/netology-code/bgo-heroku).

В большинстве случаев, приложение на Go не требует контейнеризации, поскольку мы получаем исполняемый файл, который можно развернуть в целевой операционной системе.

Контейнеризация помогает тогда, когда требуется помимо самого файла расположить ещё какие-то ресурсы (изображения, документы и т.д.).

Но самое важное - контейнеризация унифицирует процесс эксплуатации приложений на разных языках. Т.е. системным администраторам или другим сотрудникам, отвечающим за эксплуатацию приложений (в том числе развёртывание, мониторинг) будет удобнее, если все приложения будут поставляться в унифицированном формате вроде Docker образов. Именно поэтому мы рассматриваем упаковку приложений Go в образ. Если в вашей организации используются только Go приложения, либо у вас всего один-два сервера, на которых работают Go приложения, то стоит поставить под вопрос целесообразность контейнеризации.

`Dockerfile` - специальный текстовый файл, описывающий процесс создания образов (он должен находиться в корне вашего проекта).

## Layered system

Почти каждая инструкция, которую мы будем рассматривать, создаёт в рамках образа определённый слой (layer):

```
+------------------------+
|        layer N         |
+------------------------+
|        layer N - 1     |
+------------------------+
|        ...             |
+------------------------+
|        layer 1         |
+------------------------+
```

Вы можете представлять каждый слой в виде снапшота (слепка) файловой системы. Эти уровни накладываются друг на друга (снизу вверх), формируя итоговое состояние файловой системы.

Это позволяет:
1. Переиспользовать слои между несколькими образами
1. Экономить время сборки (мы переделываем только необходимые слои и все вышестоящие)

Сами слои являются неизменяемыми.

Давайте попробуем посмотреть, как работа со слоями выглядит на практике.

## `FROM`

Инструкция `FROM` позволяет выбрать базовый образ, с которого мы хотим начать создание собственного.

В качестве базового образа обычно выбирается образ одного из дистрибутивов Linux (т.е. мы получим внутри контейнера набор базовых файлов, позволяющих обеспечить работоспособность наших контейнеров)*.

Примечание*: если мы действительно хотим начать с нуля, то для этого есть специальный образ `scratch` (он, кстати, не создаёт layer'a). Пример со `scratch` вы найдёте в конце руководства.

Безусловным лидером в этой части является [Apline Linux](https://hub.docker.com/_/alpine) - минималистичный дистрибутив, весящий всего около 5 MB.

Итого наш `Dockerfile` на данном этапе должен выглядеть вот так:

```dockerfile
FROM alpine:3.7
```

## `RUN`

Инструкция `RUN` позволяет нам выполнить команды внутри контейнера, например, создать каталог, внутри которого будет находиться наш исполняемый файл:

```dockerfile
FROM alpine:3.7

RUN mkdir /app
```

Обратите внимание, если бы мы начали со `scratch` - мы бы не смогли выполнить `mkdir` (т.к. такой команды или исполняемого файла там просто нет)

Теперь можем попробовать собрать наш первый образ:

```shell script
docker build .
```

Лог:

```
Sending build context to Docker daemon  7.752MB
Step 1/2 : FROM alpine:3.7
3.7: Pulling from library/alpine
5d20c808ce19: Pull complete 
Digest: sha256:8421d9a84432575381bfabd248f1eb56f3aa21d9d7cd2511583c68c9b7511d10
Status: Downloaded newer image for alpine:3.7
 ---> 6d1ef012b567
Step 2/2 : RUN mkdir /app
 ---> Running in 46133fe28c51
Removing intermediate container 46133fe28c51
 ---> c1b8bc976056
Successfully built c1b8bc976056
```

Теперь если выполнить команду `docker image ls`, то мы увидим наш образ в списке:

```
REPOSITORY     TAG        IMAGE ID          CREATED             SIZE
<none>         <none>     c1b8bc976056      31 seconds ago      4.21MB
```

При попытке повторной сборки (`docker build .`) мы увидим, что ничего заново не соберётся, а Docker просто переиспользует полученные образы:

```
Sending build context to Docker daemon  7.752MB
Step 1/2 : FROM alpine:3.7
 ---> 6d1ef012b567
Step 2/2 : RUN mkdir /app
 ---> Using cache
 ---> c1b8bc976056
Successfully built c1b8bc976056
```

## `ADD` 

Инструкция `ADD` предоставляет вам возможность добавить из локальной файловой системы (с вашего компьютера) файлы в образ.

Формат команды следующий: `ADD src dst`, где `src` - это исходный файл, архив или URL, а `dst` - это целевой файл или каталог.

В нашем случае, нам нужно скопировать наш исполняемый файл внутрь образа.

Но образ у нас на базе Linux, поэтому и скомпилировать его нужно для Linux. Если у вас Linux:

```shell script
export GOOS=linux
export GOARCH=amd64
export CGO_ENABLED=0
go build -o bank ./cmd/bank
```

Если же Windows, то:

```shell script
set GOOS=linux
set GOARCH=amd64
set CGO_ENABLED=0
go build -o bank ./cmd/bank
```

Что такое `CGO_ENABLED`? Это указание компилятору собрать файл, не зависящий от стандартной библиотеки Си. 

Dockerfile:

```dockerfile
FROM alpine:3.7

ADD bank /app/
```

Обратите внимание, мы избавились от `RUN`, поскольку `ADD` сам создаст необходимые каталоги.

Примечание: мы пока не рассматриваем вопросы безопасности, к ним вернёмся на курсе микросервисов.

## `ENTRYPOINT`

Инструкция `ENTRYPOINT` используется для непосредственного указания исполняемого файла:

```dockerfile
FROM alpine:3.7

ADD bank /app/

ENTRYPOINT ["/app/bank"]
```

Теперь можно собрать и запустить, но давайте поговорим о следующей штуке - работать с id'шниками не совсем удобно, хотелось бы назначить образу имя (у того же `postgres` имя `postgres`). Сделать это можно с помощью флага `-t name:tag`, либо просто `-t name` (тогда тег будет `latest`).

Теперь давайте соберём всё:

```shell script
docker build . -t bank
```

Лог:

```
Sending build context to Docker daemon  7.699MB
Step 1/4 : FROM alpine:3.7
 ---> 6d1ef012b567
Step 2/4 : ADD bank /app/
 ---> a2f19f6b81c7
Step 3/4 : ENTRYPOINT ["/app/bank"]
 ---> Running in 36e50dd4669e
Removing intermediate container 36e50dd4669e
 ---> 2df2c4847897
Step 4/4 : EXPOSE 9999
 ---> Running in 8b9e65a53f3a
Removing intermediate container 8b9e65a53f3a
 ---> 14a611c55ae4
Successfully built 14a611c55ae4
Successfully tagged bank:latest
```

Запустим:

```shell script
docker container run -p 9999:9999 bank
```

Лог:

```
docker container run -p 9999:9999 bank
2020/07/27 11:36:19 0.0.0.0
2020/07/27 11:36:19 9999
```

## `EXPOSE`

Но как человек, использующий на образ узнает, какие именно порты маппить? Неужели он будет читать исходники нашего приложения.

Есть выход лучше - инструкция `EXPOSE`. Она используется для документирования того, на каком порту внутри контейнера наше приложение будет ожидать подключений (по умолчанию TCP):

```dockerfile
FROM alpine:3.7

ADD bank /app/

ENTRYPOINT ["/app/bank"]

EXPOSE 9999
```

## Итоговый `Dockerfile`

```dockerfile
FROM alpine:3.7

ADD bank /app/

ENTRYPOINT ["/app/bank"]

EXPOSE 9999
```

Итоговый `Dockerfile` необходимо закоммитить в ваш репозиторий на GitHub.

## Docker Compose

Стоит отметить, что этот `Dockerfile` можно использовать и в Docker Compose, указав внутри конкретного сервиса `build: .` и `image: bank` (будем обсуждать в рамках следующих ДЗ).

## Документация

Конечно же, мы рассмотрели лишь малую часть возможностей. Ознакомиться с документацией и примерами вы можете [на официальном сайте Docker](https://docs.docker.com/engine/reference/builder/).